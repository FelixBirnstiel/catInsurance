/*
 * Cat Insurance API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"

	"context"
	"log"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/secretsmanager"
	"github.com/google/uuid"

	_ "github.com/go-sql-driver/mysql"
	"github.com/gorilla/mux"
)

type Customer struct {
	ID                string `json:"id"`
	FirstName         string `json:"firstName"`
	LastName          string `json:"lastName"`
	Title             string `json:"title"`
	FamilyStatus      string `json:"familyStatus"`
	BirthDate         string `json:"birthDate"`
	SocialSecurityNum string `json:"socialSecurityNumber"`
	TaxID             string `json:"taxId"`
	JobStatus         string `json:"jobStatus"`
	Address           struct {
		Street      string `json:"street"`
		HouseNumber string `json:"houseNumber"`
		ZipCode     int    `json:"zipCode"`
		City        string `json:"city"`
	} `json:"address"`
	BankDetails struct {
		IBAN string `json:"iban"`
		BIC  string `json:"bic"`
		Name string `json:"name"`
	} `json:"bankDetails"`
}

type DBCredentials struct {
	Username string `json:"username"`
	Password string `json:"password"`
	Host     string `json:"host"`
	Port     int    `json:"port"`
}

// Function to retrieve database credentials from Secrets Manager
func getDBCredentials() (DBCredentials, error) {
	var dbCredentials DBCredentials

	region := "eu-central-1"
	secretName := "prod/catInsurance/mysql"

	cfg, err := config.LoadDefaultConfig(context.TODO(),
		config.WithRegion(region),
	)
	if err != nil {
		return DBCredentials{}, fmt.Errorf("failed to load AWS configuration: %v", err)
	}

	svc := secretsmanager.NewFromConfig(cfg)
	input := &secretsmanager.GetSecretValueInput{
		SecretId:     aws.String(secretName),
		VersionStage: aws.String("AWSCURRENT"),
	}

	result, err := svc.GetSecretValue(context.TODO(), input)
	if err != nil {
		return DBCredentials{}, fmt.Errorf("failed to retrieve database credentials from Secrets Manager: %v", err)
	}

	secretString := *result.SecretString

	// Parse the JSON secret string
	if err := json.Unmarshal([]byte(secretString), &dbCredentials); err != nil {
		return DBCredentials{}, fmt.Errorf("error parsing database credentials: %v", err)
	}

	return dbCredentials, nil
}

// Use getDBCredentials function to retrieve database credentials
func connectToDB() (*sql.DB, error) {
	// Retrieve database credentials
	dbCredentials, err := getDBCredentials()
	if err != nil {
		return nil, err
	}

	// Format the DSN for connecting to the MySQL database
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/meowmeddb", dbCredentials.Username, dbCredentials.Password, dbCredentials.Host, dbCredentials.Port)

	// Connect to the database
	db, err := sql.Open("mysql", dsn)
	if err != nil {
		return nil, fmt.Errorf("error connecting to database: %v", err)
	}

	return db, nil
}

func CustomersCustomerIdGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	customerID := vars["customerId"]

	if customerID == "" {
		http.Error(w, "Missing customerId parameter", http.StatusBadRequest)
		return
	}

	db, err := connectToDB()
	if err != nil {
		http.Error(w, "Error connecting to database", http.StatusInternalServerError)
		log.Fatal(err)
		return
	}
	defer db.Close()

	// Query to retrieve customer details with JOIN
	var (
		firstName, lastName, title, familyStatus, birthDate string
		socialSecurityNumber, taxId, jobStatus              string
		street, houseNumber, city                           string
		zipCode                                             int
		iban, bic, bankName                                 string
	)

	err = db.QueryRowContext(r.Context(), `
    SELECT
        c.firstName, c.lastName, COALESCE(title, '') title, c.familyStatus, c.birthDate,
        c.socialSecurityNumber, c.taxId, c.jobStatus,
        a.street, a.houseNumber, a.zipCode, a.city,
        b.iban, b.bic, b.name
    FROM
        Customer AS c
    JOIN
        Address AS a ON c.addressId = a.id
    JOIN
        BankDetails AS b ON c.bankDetailsId = b.id
    WHERE
        c.id = ?`, customerID).Scan(
		&firstName, &lastName, &title, &familyStatus, &birthDate,
		&socialSecurityNumber, &taxId, &jobStatus,
		&street, &houseNumber, &zipCode, &city,
		&iban, &bic, &bankName)
	if err != nil {
		log.Printf("Error retrieving customer details: %v", err)
		http.Error(w, "Error retrieving customer details", http.StatusInternalServerError)
		return
	}

	// Construct customer details map
	customerDetails := map[string]interface{}{
		"firstName":            firstName,
		"lastName":             lastName,
		"title":                title,
		"familyStatus":         familyStatus,
		"birthDate":            birthDate,
		"socialSecurityNumber": socialSecurityNumber,
		"taxId":                taxId,
		"jobStatus":            jobStatus,
		"address": map[string]interface{}{
			"street":      street,
			"houseNumber": houseNumber,
			"zipCode":     zipCode,
			"city":        city,
		},
		"bankDetails": map[string]string{
			"iban": iban,
			"bic":  bic,
			"name": bankName,
		},
		"id": customerID,
	}

	// Serialize customer details into JSON format
	responseJSON, err := json.Marshal(customerDetails)
	if err != nil {
		http.Error(w, "Error serializing customer details", http.StatusInternalServerError)
		return
	}

	// Set Content-Type header to indicate JSON response
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	// Write the JSON response back to the client
	w.WriteHeader(http.StatusOK)
	w.Write(responseJSON)
}

func CustomersGet(w http.ResponseWriter, r *http.Request) {
	// Parse query parameters
	page, err := strconv.Atoi(r.URL.Query().Get("page"))
	if err != nil || page < 1 {
		page = 1 // Default to page 1 if page parameter is missing or invalid
	}

	pageSize, err := strconv.Atoi(r.URL.Query().Get("pageSize"))
	if err != nil || pageSize < 1 {
		pageSize = 20 // Default page size if pageSize parameter is missing or invalid
	}

	// Calculate offset based on page number and page size
	offset := (page - 1) * pageSize

	db, err := connectToDB()
	if err != nil {
		http.Error(w, "Error connecting to database", http.StatusInternalServerError)
		log.Fatal(err)
		return
	}
	defer db.Close()

	// Query to retrieve paginated customer details
	rows, err := db.QueryContext(r.Context(), `
    SELECT
        c.id, c.firstName, c.lastName, COALESCE(c.title, '') AS title, c.familyStatus, c.birthDate,
        c.socialSecurityNumber, c.taxId, c.jobStatus,
        a.street, a.houseNumber, a.zipCode, a.city,
        b.iban, b.bic, b.name AS bankName
    FROM
        Customer AS c
    JOIN
        Address AS a ON c.addressId = a.id
    JOIN
        BankDetails AS b ON c.bankDetailsId = b.id
    ORDER BY c.id ASC
    LIMIT ? OFFSET ?`, pageSize, offset)
	if err != nil {
		http.Error(w, "Error retrieving customer details", http.StatusInternalServerError)
		log.Fatal(err)
		return
	}
	defer rows.Close()

	// Construct slice to hold customer details
	var customers []Customer

	// Iterate over the rows and populate the customers slice
	for rows.Next() {
		var customer Customer
		if err := rows.Scan(
			&customer.ID, &customer.FirstName, &customer.LastName, &customer.Title, &customer.FamilyStatus, &customer.BirthDate,
			&customer.SocialSecurityNum, &customer.TaxID, &customer.JobStatus,
			&customer.Address.Street, &customer.Address.HouseNumber, &customer.Address.ZipCode, &customer.Address.City,
			&customer.BankDetails.IBAN, &customer.BankDetails.BIC, &customer.BankDetails.Name,
		); err != nil {
			http.Error(w, "Error scanning customer details", http.StatusInternalServerError)
			log.Fatal(err)
			return
		}

		// Append customer details to the customers slice
		customers = append(customers, customer)
	}

	// Check for errors during rows iteration
	if err := rows.Err(); err != nil {
		http.Error(w, "Error iterating over customer details", http.StatusInternalServerError)
		log.Fatal(err)
		return
	}

	// Convert customers slice to JSON
	responseJSON, err := json.Marshal(customers)
	if err != nil {
		http.Error(w, "Error serializing customer details", http.StatusInternalServerError)
		log.Fatal(err)
		return
	}

	// Write JSON response
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write(responseJSON)
}

func CustomersPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	// Read request body
	var newCustomer Customer
	if err := json.NewDecoder(r.Body).Decode(&newCustomer); err != nil {
		http.Error(w, "Error decoding request body", http.StatusBadRequest)
		return
	}

	// Generate UUID for the new customer
	newCustomer.ID = uuid.New().String()

	// Retrieve database credentials
	db, err := connectToDB()
	if err != nil {
		http.Error(w, "Error connecting to database", http.StatusInternalServerError)
		log.Fatal(err)
		return
	}
	defer db.Close()

	// Begin transaction
	tx, err := db.Begin()
	if err != nil {
		http.Error(w, "Error starting transaction", http.StatusInternalServerError)
		return
	}

	// Insert into Address table
	addressID := uuid.New().String() // Generate UUID for the address
	_, err = tx.ExecContext(context.Background(), `
		INSERT INTO Address (id, street, houseNumber, zipCode, city)
		VALUES (?, ?, ?, ?, ?)`,
		addressID, newCustomer.Address.Street, newCustomer.Address.HouseNumber, newCustomer.Address.ZipCode, newCustomer.Address.City)
	if err != nil {
		tx.Rollback()
		http.Error(w, "Error inserting into Address table", http.StatusInternalServerError)
		return
	}

	// Insert into BankDetails table
	bankDetailsID := uuid.New().String() // Generate UUID for the bank details
	_, err = tx.ExecContext(context.Background(), `
		INSERT INTO BankDetails (id, iban, bic, name)
		VALUES (?, ?, ?, ?)`,
		bankDetailsID, newCustomer.BankDetails.IBAN, newCustomer.BankDetails.BIC, newCustomer.BankDetails.Name)
	if err != nil {
		tx.Rollback()
		http.Error(w, "Error inserting into BankDetails table", http.StatusInternalServerError)
		return
	}

	// Insert into Customer table
	_, err = tx.ExecContext(context.Background(), `
		INSERT INTO Customer (id, firstName, lastName, title, familyStatus, birthDate, socialSecurityNumber, taxId, jobStatus, addressId, bankDetailsId)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
		newCustomer.ID, newCustomer.FirstName, newCustomer.LastName, newCustomer.Title, newCustomer.FamilyStatus, newCustomer.BirthDate, newCustomer.SocialSecurityNum, newCustomer.TaxID, newCustomer.JobStatus, addressID, bankDetailsID)
	if err != nil {
		tx.Rollback()
		http.Error(w, "Error inserting into Customer table", http.StatusInternalServerError)
		return
	}

	// Commit transaction
	if err := tx.Commit(); err != nil {
		http.Error(w, "Error committing transaction", http.StatusInternalServerError)
		return
	}

	// Respond with the new customer details
	responseJSON, err := json.Marshal(newCustomer)
	if err != nil {
		http.Error(w, "Error serializing customer details", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Write(responseJSON)
}

func CustomersSearchGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func CustomersCustomerIdDelete(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func CustomersCustomerIdPatch(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

/*func CustomersCustomerIdContractsGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
} */
